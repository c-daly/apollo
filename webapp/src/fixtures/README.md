# CWM Mock Fixtures Documentation

## Overview

The Apollo webapp includes reusable mock fixtures for Continuous World Model (CWM) state streams and JEPA (Joint-Embedding Predictive Architecture) outputs. These fixtures enable deterministic development and testing without requiring live backend services.

## Purpose

Mock fixtures serve several key purposes:

1. **Development**: Work on the UI without dependencies on Sophia, Hermes, or Talos services
2. **Testing**: Create reproducible test scenarios with known data
3. **Debugging**: Isolate UI issues from backend concerns
4. **Demos**: Show consistent behavior for presentations and documentation
5. **CI/CD**: Run frontend tests without backend infrastructure

## CWM Record Types

The CWM (Continuous World Model) tracks three primary record types, all wrapped in a unified envelope format:

### CWM-A: Actions/Activities
Records representing actions performed by the agent:
- **Action type**: navigate, grasp, place, etc.
- **Status**: pending, executing, completed, failed
- **Parameters**: action-specific configuration
- **Results**: success/failure, output data, errors
- **Preconditions**: required conditions before action
- **Effects**: expected state changes after action

### CWM-G: Goals with Visual Frames
Records representing goals with associated visual observations:
- **Goal description**: natural language description
- **Priority**: low, medium, high, critical
- **Status**: active, suspended, achieved, abandoned
- **Progress**: 0-100% completion
- **Frames**: visual observations, predictions, or simulations
- **Context**: location, actors, related goals

### CWM-E: Events
Records representing observed environmental events:
- **Event type**: obstacle_detected, state_transition, etc.
- **Severity**: info, warning, error, critical
- **Source**: which system detected the event
- **Properties**: event-specific data
- **Related entities**: connections to actions, goals, etc.

## Visual Frames (CWM-G)

CWM-G records include visual frame data with rich metadata:

```typescript
interface CWMFrame {
  frame_id: string
  timestamp: string
  frame_type: 'observation' | 'prediction' | 'simulation'
  encoding: 'base64' | 'url' | 'tensor'
  data: string // Image data or URL
  dimensions?: {
    width: number
    height: number
    channels?: number
  }
  metadata: {
    camera_id?: string
    resolution?: string
    format?: string
    confidence?: number
    annotations?: Array<{
      label: string
      bbox?: [number, number, number, number]
      confidence?: number
    }>
  }
}
```

**Frame types:**
- **observation**: Actual captured images from cameras/sensors
- **prediction**: Future predictions generated by JEPA
- **simulation**: Simulated views for planning

## JEPA Outputs

JEPA (Joint-Embedding Predictive Architecture) outputs contain learned representations and predictions:

- **Embeddings**: Vector representations of current and predicted states
- **Predictions**: Multi-horizon forecasts with confidence scores
- **Metrics**: Model performance (loss, accuracy, latency)

## Available Fixtures

### 1. `mockCWMStateStream` (Default)
Full-featured stream with mixed CWM-A/G/E records:
- 7 total records (3 actions, 2 goals, 2 events)
- 2 JEPA outputs
- ~425 seconds duration
- Includes successes, in-progress, and failures

### 2. `mockCWMStateStreamShort`
Quick test stream:
- 3 records (1 of each type)
- 1 JEPA output
- 60 seconds duration
- Ideal for unit tests

### 3. `mockCWMStateStreamFailures`
Error scenario stream:
- 1 failed action record
- No JEPA outputs
- Useful for testing error handling

### Individual Collections
- `mockCWMActions`: Array of action records
- `mockCWMGoals`: Array of goal records with frames
- `mockCWMEvents`: Array of event records
- `mockJEPAOutputs`: Array of JEPA outputs

## Usage

### Basic Usage

```typescript
import { mockCWMStateService, toggleMockMode } from '@/fixtures'

// Switch to mock mode
toggleMockMode()

// Get the full default stream
const stream = mockCWMStateService.getFullStream('default')
console.log(stream.metadata.total_records) // 7

// Get records by type
const actions = mockCWMStateService.getRecordsByType('CWM-A')
const goals = mockCWMStateService.getRecordsByType('CWM-G')
const events = mockCWMStateService.getRecordsByType('CWM-E')

// Get JEPA outputs
const jepaOutputs = mockCWMStateService.getJEPAOutputs()
```

### Streaming Mode

Subscribe to real-time record streaming:

```typescript
import { mockCWMStateService } from '@/fixtures'

// Subscribe to stream updates
const unsubscribe = mockCWMStateService.subscribe((record) => {
  if (record) {
    console.log('New record:', record.record_type, record.record_id)
    console.log('Payload:', record.payload)
  } else {
    console.log('Stream complete')
  }
})

// Start streaming (with 100ms delay between records)
mockCWMStateService.startStream()

// Stop streaming when done
// unsubscribe()
```

### Load Different Streams

```typescript
import {
  mockCWMStateService,
  mockCWMStateStreamShort,
  mockCWMStateStreamFailures
} from '@/fixtures'

// Load short stream
mockCWMStateService.loadStream(mockCWMStateStreamShort)

// Or use convenience method
const stream = mockCWMStateService.getFullStream('short')
// Options: 'default', 'short', 'failures'
```

### React Integration

```typescript
import { useEffect, useState } from 'react'
import { mockCWMStateService } from '@/fixtures'
import type { CWMEnvelope } from '@/fixtures'

function CWMStreamViewer() {
  const [records, setRecords] = useState<CWMEnvelope[]>([])

  useEffect(() => {
    const unsubscribe = mockCWMStateService.subscribe((record) => {
      if (record) {
        setRecords((prev) => [...prev, record])
      }
    })

    mockCWMStateService.startStream()

    return unsubscribe
  }, [])

  return (
    <div>
      <h2>CWM Stream</h2>
      {records.map((record) => (
        <div key={record.record_id}>
          <strong>{record.record_type}</strong>: {record.record_id}
        </div>
      ))}
    </div>
  )
}
```

## Configuration

### Environment Variables

Control mock mode via environment variables:

```bash
# In .env file
VITE_MOCK_DATA_MODE=true  # Enable mock mode
VITE_MOCK_DATA_MODE=false # Use live data (default)
```

### Runtime Toggle

Switch between modes programmatically:

```typescript
import { toggleMockMode, isMockMode } from '@/fixtures'

// Check current mode
console.log('Mock mode:', isMockMode()) // true or false

// Toggle mode
const newMode = toggleMockMode()
console.log('Switched to:', newMode) // 'mock' or 'live'
```

### Service Configuration

Create custom service instances:

```typescript
import { MockCWMStateService } from '@/fixtures'

const customService = new MockCWMStateService({
  mode: 'mock',
  streamDelay: 200,     // 200ms between records
  randomize: true,      // Add random jitter (±20%)
})
```

## NPM Tasks

### Run with Mock Data

```bash
# Start dev server with mock data enabled
npm run dev:mock

# Normal dev server (uses .env setting)
npm run dev
```

The `dev:mock` task sets `VITE_MOCK_DATA_MODE=true` at runtime, overriding the `.env` file.

## Testing

### Unit Tests

```typescript
import { describe, it, expect } from 'vitest'
import { mockCWMStateStream, MockCWMStateService } from '@/fixtures'

describe('CWM Fixtures', () => {
  it('should have correct record counts', () => {
    expect(mockCWMStateStream.metadata.total_records).toBe(7)
    expect(mockCWMStateStream.metadata.record_counts.actions).toBe(3)
    expect(mockCWMStateStream.metadata.record_counts.goals).toBe(2)
    expect(mockCWMStateStream.metadata.record_counts.events).toBe(2)
  })

  it('should stream records in order', () => {
    const service = new MockCWMStateService({ mode: 'mock' })
    service.loadStream(mockCWMStateStream)

    const record1 = service.getNextRecord()
    const record2 = service.getNextRecord()

    expect(record1?.sequence_number).toBe(1)
    expect(record2?.sequence_number).toBe(2)
  })
})
```

### Integration Tests

Test UI components with fixture data:

```typescript
import { render, screen, waitFor } from '@testing-library/react'
import { MockCWMStateService } from '@/fixtures'
import CWMViewer from '@/components/CWMViewer'

it('should display CWM records', async () => {
  const service = new MockCWMStateService({ mode: 'mock' })
  service.loadDefaultStream()

  render(<CWMViewer service={service} />)

  service.startStream()

  await waitFor(() => {
    expect(screen.getByText(/cwm-a-001/i)).toBeInTheDocument()
  })
})
```

## Data Structure

### Unified Envelope Format

All CWM records use a consistent envelope:

```typescript
interface CWMEnvelope<T> {
  record_type: 'CWM-A' | 'CWM-G' | 'CWM-E'
  record_id: string
  timestamp: string      // ISO 8601
  sequence_number: number
  payload: T            // Type-specific payload
  metadata: {
    source: string
    version: string
    [key: string]: unknown
  }
}
```

### Stream Structure

Streams contain collections of records:

```typescript
interface CWMStateStream {
  stream_id: string
  start_time: string
  end_time?: string
  records: Array<CWMEnvelope>
  jepa_outputs?: JEPAOutput[]
  metadata: {
    total_records: number
    record_counts: {
      actions: number
      goals: number
      events: number
    }
    source: string
    [key: string]: unknown
  }
}
```

## File Structure

```
webapp/src/fixtures/
├── cwm-types.ts       # TypeScript type definitions
├── cwm-fixtures.ts    # Sample fixture data
├── mock-service.ts    # Mock data service
├── index.ts           # Public exports
└── README.md          # This file
```

## Best Practices

1. **Use Type-Safe Imports**: Import types separately from values
   ```typescript
   import type { CWMEnvelope } from '@/fixtures'
   import { mockCWMStateStream } from '@/fixtures'
   ```

2. **Load Appropriate Fixtures**: Use short streams for unit tests, full streams for integration tests

3. **Clean Up Subscriptions**: Always unsubscribe when components unmount
   ```typescript
   useEffect(() => {
     const unsubscribe = service.subscribe(callback)
     return unsubscribe
   }, [])
   ```

4. **Test Error Scenarios**: Use the failures fixture to test error handling

5. **Don't Commit Mock Mode**: Keep `VITE_MOCK_DATA_MODE=false` in `.env` for production

## Troubleshooting

### Mock mode not working?
- Check `.env` file has `VITE_MOCK_DATA_MODE=true`
- Verify environment variable is loaded: `console.log(import.meta.env.VITE_MOCK_DATA_MODE)`
- Try running `npm run dev:mock` instead of `npm run dev`

### Stream not progressing?
- Ensure you called `startStream()` after subscribing
- Check that mode is set to 'mock': `isMockMode()`
- Verify stream is loaded: `service.getStreamStats()`

### TypeScript errors?
- Run `npm run type-check` to verify types
- Ensure `vite-env.d.ts` includes `VITE_MOCK_DATA_MODE`
- Restart TypeScript server in your IDE

## Future Enhancements

Potential improvements for future versions:

- [ ] Add more diverse fixture scenarios (edge cases, complex interactions)
- [ ] Include actual base64-encoded images for frames
- [ ] Add WebSocket mock server for real-time streaming
- [ ] Generate fixtures programmatically from test scenarios
- [ ] Add fixture validation against OpenAPI schemas
- [ ] Support custom fixture loading from JSON files
- [ ] Add fixture recording from live sessions

## Related Documentation

- [Main README](../../../README.md)
- [API Clients](../../../docs/API_CLIENTS.md)
- [HCG Data Layer](../../../docs/HCG_DATA_LAYER.md)

## Questions?

If you have questions or need additional fixtures, please:
1. Check existing issues in the repository
2. Review the example usage in `webapp/src/examples/`
3. Open a new issue with the `fixtures` label
